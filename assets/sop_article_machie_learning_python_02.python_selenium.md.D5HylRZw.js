import{j as e,b as a,c as s,aa as n}from"./chunks/framework.Dkh8-idd.js";const _=JSON.parse('{"title":"3. selenium 运行时打开当前浏览器","description":"","frontmatter":{"title":"3. selenium 运行时打开当前浏览器","date":"2024-03-18T17:35:31.000Z","tags":["Web","python"],"cover":"https://miro.medium.com/v2/resize:fit:1400/1*ycIMlwgwicqlO6PcFRA-Iw.png","hiddenCover":true},"headers":[],"relativePath":"sop/article/machie_learning/python/02.python_selenium.md","filePath":"sop/article/machie_learning/python/02.python_selenium.md","lastUpdated":1712454356000}'),p={name:"sop/article/machie_learning/python/02.python_selenium.md"},t=n(`<h1 id="selenium-运行时打开当前浏览器" tabindex="-1">selenium 运行时打开当前浏览器 <a class="header-anchor" href="#selenium-运行时打开当前浏览器" aria-label="Permalink to &quot;selenium 运行时打开当前浏览器&quot;">​</a></h1><p>做网页自动化测试时，需要执行脚本。但往往需要不断重新打开一个新页面。带来的负面影响就是环境被清空。 我们希望直接使用同一个环境的情况可以如下操作。</p><h2 id="配置运行环境" tabindex="-1">配置运行环境 <a class="header-anchor" href="#配置运行环境" aria-label="Permalink to &quot;配置运行环境&quot;">​</a></h2><p>终端执行将谷歌浏览器配到环境变量中</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// zhrc shell环境</span></span>
<span class="line"><span>export PATH=&quot;/Applications/Google Chrome.app/Contents/MacOS:$PATH&quot;</span></span>
<span class="line"><span>source ~/.zshrc</span></span></code></pre></div><h2 id="用一个固定端口启动浏览器" tabindex="-1">用一个固定端口启动浏览器 <a class="header-anchor" href="#用一个固定端口启动浏览器" aria-label="Permalink to &quot;用一个固定端口启动浏览器&quot;">​</a></h2><p>固定端口是为了每次启动，都能获得同一个进程应用。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Google\\ Chrome --remote-debugging-port=9222 --user-data-dir=&quot;~/ChromeProfile&quot;</span></span>
<span class="line"><span>// mac</span></span>
<span class="line"><span>sudo &#39;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#39; --remote-debugging-port=9222 --user-data-dir=&quot;~/ChromeProfile&quot;</span></span></code></pre></div><h2 id="运行脚本前置唤起" tabindex="-1">运行脚本前置唤起 <a class="header-anchor" href="#运行脚本前置唤起" aria-label="Permalink to &quot;运行脚本前置唤起&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>from selenium import webdriver</span></span>
<span class="line"><span>from selenium.webdriver.common.by import By</span></span>
<span class="line"><span>from selenium.webdriver.support.ui import WebDriverWait</span></span>
<span class="line"><span>from selenium.webdriver.support import expected_conditions as EC</span></span>
<span class="line"><span>from selenium.webdriver import ActionChains</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>options = webdriver.ChromeOptions()</span></span>
<span class="line"><span>options.add_experimental_option(&quot;debuggerAddress&quot;, &quot;127.0.0.1:9222&quot;)</span></span>
<span class="line"><span># options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])</span></span>
<span class="line"><span>browser = webdriver.Chrome(executable_path=chromedriver_path, options=options)</span></span></code></pre></div>`,10),i=[t];function o(l,r,c,d,h,m){return a(),s("div",null,i)}const b=e(p,[["render",o]]);export{_ as __pageData,b as default};
