import{j as a,b as n,c as s,aa as e,aQ as o,aR as t}from"./chunks/framework.Dkh8-idd.js";const b=JSON.parse('{"title":"Unity基于用户输入的对象移动","description":"","frontmatter":{"title":"Unity基于用户输入的对象移动","date":"2024-03-17T06:00:31.000Z","tags":["unity"],"cover":"https://s.yimg.com/ny/api/res/1.2/frr7UBkGb2ZttpkNPinS.g--/YXBwaWQ9aGlnaGxhbmRlcjt3PTY0MDtoPTM4NA--/https://s.yimg.com/os/creatr-uploaded-images/2023-09/dc057330-51b1-11ee-9e6f-7e13a99ea9c5","hiddenCover":true},"headers":[],"relativePath":"sop/article/图形与游戏/unity/01.unity.md","filePath":"sop/article/图形与游戏/unity/01.unity.md","lastUpdated":1710694215000}'),p={name:"sop/article/图形与游戏/unity/01.unity.md"},i=e('<h1 id="unity基于用户输入的对象移动" tabindex="-1">unity基于用户输入的对象移动 <a class="header-anchor" href="#unity基于用户输入的对象移动" aria-label="Permalink to &quot;unity基于用户输入的对象移动&quot;">​</a></h1><p>这里讲一下向量位置Vector3，它表示物体在三维世界里的位置。<br><img src="'+o+`" alt="坐标系"> 在Unity三维坐标系，分为全局坐标系和相对坐标系。</p><ul><li><code>全局坐标系</code>也叫<code>世界坐标系</code>：默认起始点是(0,0,0). 当一个物体在世界坐标系(1,1,1)位置的时候，我们就知道它是在世界坐标系的右上方。</li><li><code>相对坐标系</code>也叫<code>模型坐标系</code>：它以对象自身位置为中心点，比如上面的对象位置(1,1,1)。<br> 假设模型位置叫做A, 当我们说物体B在模型坐标系的(1,1,1)的时候，那么它在世界坐标系位置，是A + B,即真实位置是(2,2,2)。</li></ul><p><b>用户操作对象移动，通常有两种方式</b>：</p><pre><code>1. 通过c#中的Input对象，改变对象transform的position来达到。
2. 通过添加刚体Rigidbody，模拟重力方式，给对象增加一个推力AddForce。
</code></pre><h2 id="_1-用户键盘输入input" tabindex="-1">1. 用户键盘输入Input <a class="header-anchor" href="#_1-用户键盘输入input" aria-label="Permalink to &quot;1. 用户键盘输入Input&quot;">​</a></h2><p>获取用户输入的方式，通常只有前后、左右箭头、和aswd键盘，用户可以在项目设置的InputManager里设置。</p><p>InputManager设置，以macOS unity为例子：<br> 选中unity项目，顶部菜单栏 &gt; Edit &gt; Project Settings &gt; InputManager，点开Axes自行修改对应的key。</p><p><img src="`+t+`" alt="input"></p><p>修改完后，我们就可以通过Input获取InputManager里的设定内容.</p><h3 id="_1-1-input-getaxis方式获取水平、垂直方向" tabindex="-1">1.1 Input.GetAxis方式获取水平、垂直方向 <a class="header-anchor" href="#_1-1-input-getaxis方式获取水平、垂直方向" aria-label="Permalink to &quot;1.1 Input.GetAxis方式获取水平、垂直方向&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>//方式一：通过GetAxis的方式</span></span>
<span class="line"><span>//获取水平方向</span></span>
<span class="line"><span>float Horizontal = Input.GetAxis(&quot;Horizontal&quot;);</span></span>
<span class="line"><span>//获取前后方向</span></span>
<span class="line"><span>float Vertical = Input.GetAxis(&quot;Vertical&quot;);</span></span></code></pre></div><p>通过GetAxis方式，在设置按键被按下时，即可获得对应的返回。 GetAxis返回是一个浮点数，范围在<code>[-1,1]</code>之间，表示用户按下力度的大小偏移量。</p><h3 id="_1-2-input-getkeydown方式获取键盘按下" tabindex="-1">1.2 Input.GetKeyDown方式获取键盘按下 <a class="header-anchor" href="#_1-2-input-getkeydown方式获取键盘按下" aria-label="Permalink to &quot;1.2 Input.GetKeyDown方式获取键盘按下&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>//方式2：通过获取键盘按下GetKeyDown的方式</span></span>
<span class="line"><span>Boolean isMoveLeft = Input.GetKeyDown(KeyCode.LeftArrow);</span></span>
<span class="line"><span>Boolean isMoveRight = Input.GetKeyDown(KeyCode.RightArrow);</span></span>
<span class="line"><span>Boolean isMoveForward = Input.GetKeyDown(KeyCode.UpArrow);</span></span>
<span class="line"><span>Boolean isMoveBackground = Input.GetKeyDown(KeyCode.DownArrow);</span></span></code></pre></div><p>通过GetKeyDown/GetKeyUp检测按键按下和弹起，按哪个按键可以通过KeyCode.xx 来指定。 KeyCode是Unity内置的按键枚举，比如空白按键KeyCode.Space。</p><h2 id="_2-对象移动" tabindex="-1">2. 对象移动 <a class="header-anchor" href="#_2-对象移动" aria-label="Permalink to &quot;2. 对象移动&quot;">​</a></h2><p>对象的移动,可以通过修改postion大小来改变；也可以通过给对象增加推力，让其自行调整postion位置。</p><h3 id="_2-1-postion大小修改" tabindex="-1">2.1 postion大小修改 <a class="header-anchor" href="#_2-1-postion大小修改" aria-label="Permalink to &quot;2.1 postion大小修改&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>float x = 1;</span></span>
<span class="line"><span>float y = 1;</span></span>
<span class="line"><span>float z = 1;</span></span>
<span class="line"><span>Vector3 newPostion = new Vector3(x,y,z);</span></span>
<span class="line"><span>transform.position = newPostion;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//移动指定向量偏移量</span></span>
<span class="line"><span>float speed = 30.0f;</span></span>
<span class="line"><span>float Vertical = Input.GetAxis(&quot;Vertical&quot;);</span></span>
<span class="line"><span>transform.Translate(Vector3.forward * Time.deltaTime * speed * Vertical);</span></span></code></pre></div><p>直接修改postion的方式，比较简单。</p><ul><li>通过提供一个新的Vector3 向量位置</li><li>通过Unity的Translate方法，给位置增加偏移向量。</li></ul><h3 id="_2-2-addforce添加推力" tabindex="-1">2.2 AddForce添加推力 <a class="header-anchor" href="#_2-2-addforce添加推力" aria-label="Permalink to &quot;2.2 AddForce添加推力&quot;">​</a></h3><p>给对象添加一个推力，我们需要给对象添加一个刚体Rigidbody组件，它表示物理世界的重力属性。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Boolean isMoveLeft = Input.GetKeyDown(KeyCode.LeftArrow);</span></span>
<span class="line"><span>Boolean isMoveRight = Input.GetKeyDown(KeyCode.RightArrow);</span></span>
<span class="line"><span>Boolean isMoveForward = Input.GetKeyDown(KeyCode.UpArrow);</span></span>
<span class="line"><span>Boolean isMoveBackground = Input.GetKeyDown(KeyCode.DownArrow);</span></span>
<span class="line"><span>float Horizontal = Input.GetAxis(&quot;Horizontal&quot;);</span></span>
<span class="line"><span>float Vertical = Input.GetAxis(&quot;Vertical&quot;);</span></span>
<span class="line"><span>float speed   = 10; </span></span>
<span class="line"><span>float zBound = 4.5f;</span></span>
<span class="line"><span>// GetAxis方式</span></span>
<span class="line"><span>GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.right * Horizontal * speed);</span></span>
<span class="line"><span>GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.forward *Vertical*speed);</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>//keydown方式 </span></span>
<span class="line"><span>if (isMoveLeft || isMoveRight) {</span></span>
<span class="line"><span>    float force = isMoveLeft ? 10 : 0;</span></span>
<span class="line"><span>    force = isMoveRight ? -10 : force;</span></span>
<span class="line"><span>    GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.left * Horizontal * speed, ForceMode.Impulse);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (isMoveForward || isMoveBackground) {</span></span>
<span class="line"><span>    float force = isMoveForward ? 10 : 0;</span></span>
<span class="line"><span>    force = isMoveBackground ? -10 : force;</span></span>
<span class="line"><span>    GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.forward *Horizontal*speed, ForceMode.Impulse);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>上面AddForce例子里，force 10/-10表示一个正向反向的推力，推力方向是Vector3.right和Vector3.forward，模式是ForceMode.Impulse。</p><p><code>ForceMode</code> 是 Unity 中的一个枚举类型，用于指定在施加力或作用力时的力的模式。它定义了四种不同的模式：</p><ol><li><p><strong>Force</strong>：在刚体上施加一个连续的力，使用刚体的质量。这意味着力将持续作用于物体，直到另一个力或相反方向的力抵消它。通常用于模拟持续的力，比如重力或者推力。</p></li><li><p><strong>Impulse</strong>：在刚体上施加一个瞬时冲量，使用刚体的质量。这意味着力将一次性作用于物体，然后立即停止。通常用于模拟瞬时的力，比如碰撞或爆炸。</p></li><li><p><strong>VelocityChange</strong>：在刚体上施加一个瞬时速度变化，忽略刚体的质量。这意味着物体将立即改变其速度，而不考虑其质量。通常用于直接改变物体的速度，而不考虑惯性。</p></li><li><p><strong>Acceleration</strong>：在刚体上施加一个连续的加速度，忽略刚体的质量。这意味着物体将以恒定的加速度持续加速，直到另一个力或相反方向的力抵消它。通常用于模拟持续的加速度，比如风或推力。</p></li></ol><p>这些不同的模式允许开发者根据场景的需求来选择合适的力的作用方式，从而实现更精确的物理模拟和游戏行为。</p><h2 id="_3-优缺点" tabindex="-1">3. 优缺点 <a class="header-anchor" href="#_3-优缺点" aria-label="Permalink to &quot;3. 优缺点&quot;">​</a></h2><p>这两种方式各有优劣，具体取决于你的需求和场景。</p><h3 id="_1-直接修改位置-transform-position" tabindex="-1">1. <strong>直接修改位置 (<code>transform.position</code>)：</strong> <a class="header-anchor" href="#_1-直接修改位置-transform-position" aria-label="Permalink to &quot;1. **直接修改位置 (\`transform.position\`)：**&quot;">​</a></h3><ul><li><strong>优点：</strong><ul><li>简单直接：直接修改位置参数，代码量少，容易理解和实现。</li><li>精确控制：可以精确地将物体移动到指定的位置，不受物理系统的影响。</li></ul></li><li><strong>缺点：</strong><ul><li>不受物理系统约束：直接修改位置不受物理引擎的约束，可能会绕过碰撞检测，导致物体穿过其他物体或产生意外的行为。</li><li>不适合动态场景：如果物体需要受到力的影响，例如重力、摩擦力等，直接修改位置可能无法满足需求。</li></ul></li></ul><h3 id="_2-施加力-rigidbody-addforce" tabindex="-1">2. <strong>施加力 (<code>Rigidbody.AddForce())</code>：</strong> <a class="header-anchor" href="#_2-施加力-rigidbody-addforce" aria-label="Permalink to &quot;2. **施加力 (\`Rigidbody.AddForce())\`：**&quot;">​</a></h3><ul><li><strong>优点：</strong><ul><li>物理仿真：通过施加力的方式，物体会受到物理系统的影响，可以模拟真实世界中的物体运动行为，例如惯性、摩擦力、碰撞等。</li><li>自然流畅：施加力可以使物体的运动更自然、流畅，更符合真实物理规律。</li></ul></li><li><strong>缺点：</strong><ul><li>复杂性：与直接修改位置相比，使用物理引擎需要更多的代码和配置来控制物体的移动，尤其是在需要调整力的大小和方向时。</li><li>相对性能较低：物理仿真需要消耗额外的计算资源，可能会对性能产生一定的影响。</li></ul></li></ul><p>综合来说，如果你的场景需要模拟真实物理行为，或者需要让物体受到力的影响，那么使用 <code>Rigidbody.AddForce()</code> 更为合适。但如果你只是简单地需要将物体移动到某个位置，且不需要考虑物理因素，那么直接修改位置可能更简单和有效。</p>`,36),l=[i];function r(c,d,u,h,g,y){return n(),s("div",null,l)}const m=a(p,[["render",r]]);export{b as __pageData,m as default};
